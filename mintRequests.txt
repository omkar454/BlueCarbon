// backend/routes/mintRequests.js
import express from "express";
import MintRequest from "../models/mintRequests.js";
import Project from "../models/Project.js";
import { ethers } from "ethers";
import tokenJson from "../contracts/CarbonCreditToken.json" assert { type: "json" };
import dotenv from "dotenv";

dotenv.config({ path: "C:\\bluecarbon-mvp\\backend\\.env" });

const router = express.Router();
const provider = new ethers.JsonRpcProvider(process.env.ALCHEMY_RPC_URL);

const tokenAddress = process.env.TOKEN_CONTRACT_ADDRESS;
const tokenInterface = new ethers.Interface(tokenJson.abi);

// ‚úÖ NCCR / Owner wallet (needed for create-request, onlyOwner)
const ownerWallet = new ethers.Wallet(
  process.env.DEPLOYER_PRIVATE_KEY,
  provider
);
const tokenContract = new ethers.Contract(
  tokenAddress,
  tokenJson.abi,
  ownerWallet
);

/* -------------------- CREATE MINT REQUEST -------------------- */
router.post("/create-request", async (req, res) => {
  try {
    const { projectId, ngoAddress, amount } = req.body;

    if (!projectId || !ngoAddress || !amount) {
      return res.status(400).json({ success: false, error: "Missing fields" });
    }

    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ success: false, error: "Project not found" });
    }

    console.log("‚úÖ Creating mint request on-chain...");

    const amountParsed = ethers.parseUnits(amount.toString(), 18);
    const tx = await tokenContract.createMintRequest(ngoAddress, amountParsed);
    const receipt = await tx.wait();

    console.log("üìÑ Transaction receipt:", receipt);

    // Parse logs for MintRequested
    const event = receipt.logs
      .map((l) => {
        try {
          return tokenInterface.parseLog(l);
        } catch (err) {
          return null;
        }
      })
      .find((e) => e && e.name === "MintRequested");

    if (!event) {
      console.warn("‚ö†Ô∏è MintRequested event not found in logs! Saving with temporary requestId.");
    }

    const requestId = event?.args?.requestId?.toString() || `temp-${Date.now()}`;

    // Save to MongoDB
    const mintRequest = new MintRequest({
      projectId: project._id,
      requestId,
      amount: amount.toString(),
      status: "Pending",
      approvals: {},
    });

    await mintRequest.save();
    console.log("üíæ Mint request saved in MongoDB:", mintRequest);

    // Link to project
    project.mintRequests.push(mintRequest._id);
    await project.save();
    console.log("üîó Mint request linked to project.");

    res.json({ success: true, txHash: tx.hash, requestId, mintRequest });
  } catch (err) {
    console.error("‚ùå Create mint request error:", err);
    res.status(500).json({ success: false, error: err.message });
  }
});

/* -------------------- SAVE MINT REQUEST -------------------- */
/* router.post("/saveMintRequest", async (req, res) => {
  try {
    const { projectId, requestId, amount } = req.body;

    const project = await Project.findById(projectId);
    if (!project) {
      return res
        .status(404)
        .json({ success: false, error: "Project not found" });
    }

    const mintRequest = new MintRequest({
      projectId: project._id,
      requestId: requestId.toString(),
      amount: amount.toString(),
      status: "Pending",
      approvals: {},
    });

    await mintRequest.save();
    project.mintRequests.push(mintRequest._id);
    await project.save();

    res.json({ success: true, mintRequest });
  } catch (err) {
    console.error("‚ùå Save mint request error:", err);
    res.status(500).json({ success: false, error: err.message });
  }
}); */

/* -------------------- GET MINT REQUESTS FOR PROJECT -------------------- */
router.get("/project/:projectId", async (req, res) => {
  try {
    const { projectId } = req.params;
    const mintRequests = await MintRequest.find({ projectId }).sort({
      createdAt: -1,
    });
    res.json({ success: true, mintRequests });
  } catch (err) {
    console.error("‚ùå Fetch mint requests error:", err);
    res.status(500).json({ success: false, error: err.message });
  }
});

/* -------------------- APPROVE BY VERIFIER -------------------- */
router.post("/approveByVerifier", async (req, res) => {
  try {
    const { requestId, verifierPrivateKey } = req.body;
    if (!requestId || !verifierPrivateKey) {
      return res.status(400).json({ success: false, error: "Missing fields" });
    }

    // Find mint request and populate project for verifier list
    const mintRequest = await MintRequest.findOne({
      requestId: requestId.toString(),
    }).populate("projectId");
    if (!mintRequest) {
      return res
        .status(404)
        .json({ success: false, error: "Mint request not found" });
    }

    const project = mintRequest.projectId;
    if (!project) {
      return res
        .status(404)
        .json({ success: false, error: "Associated project not found" });
    }

    const verifierWallet = new ethers.Wallet(verifierPrivateKey, provider);
    const verifierAddress = await verifierWallet.getAddress();

    // Ensure verifier is assigned to this project
    if (!project.verifiers.includes(verifierAddress)) {
      return res.status(403).json({
        success: false,
        error: "Verifier not assigned to this project",
      });
    }

    // Prevent duplicate approval
    if (mintRequest.approvals[verifierAddress]) {
      return res
        .status(400)
        .json({ success: false, error: "Already approved by this verifier" });
    }

    // On-chain approveMint
    const verifierContract = new ethers.Contract(
      tokenAddress,
      tokenJson.abi,
      verifierWallet
    );
    const onchainId = BigInt(requestId.toString());
    const tx = await verifierContract.approveMint(onchainId);
    const receipt = await tx.wait();

    // Update DB approvals
    mintRequest.approvals[verifierAddress] = true;

    // Parse logs for MintExecuted
    let executed = false;
    for (const log of receipt.logs) {
      try {
        const parsed = tokenInterface.parseLog(log);
        if (parsed.name === "MintExecuted") {
          executed = true;
          break;
        }
      } catch (e) {
        // skip unrelated logs
      }
    }

    if (executed) {
      mintRequest.status = "Executed";
    } else {
      mintRequest.status = "Approved"; // waiting for more approvals
    }

    await mintRequest.save();

    res.json({
      success: true,
      txHash: tx.hash,
      mintRequest: {
        ...mintRequest.toObject(),
        approvedVerifiers: Object.keys(mintRequest.approvals),
      },
    });
  } catch (err) {
    console.error("‚ùå Verifier approval error:", err);
    const msg = err?.reason || err?.message || "Server error";
    res.status(500).json({ success: false, error: msg });
  }
});

export default router;
